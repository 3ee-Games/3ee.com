import{S as Ga,i as Ra,s as Ja,C as Zt,w as Ma,x as Ha,y as Ua,z as Ya,A as Da,q as Ka,o as Qa,B as Za,Z as Ba,e as o,t as r,k as h,c as n,a as l,h as p,d as t,m as d,b as m,g as s,I as a,E as Va}from"../../chunks/index-204a5ff7.js";import{P as Xa}from"../../chunks/_post-895cd53f.js";import"../../chunks/Player-ffbd4510.js";import"../../chunks/menuContextStore-53a673f3.js";import"../../chunks/index-e5f9449a.js";function ei(z){let c,g,w,b,f,y,O,v,A,oe,Qe,Ze,Ve,L,ne,Xe,et,tt,q,le,at,it,_e,C,st,ke,D,ot,xe,B,nt,Ee,F,lt,Te,N,re,rt,Pe,$,pt,Ie,G,ht,je,R,dt,Se,x,E,pe,ct,Oe,J,ft,We,M,mt,ze,H,ut,Ae,T,he,yt,gt,de,wt,Le,U,bt,qe,Y,vt,Ce,K,ce,_t,De,Q,kt,Be,P,I,fe,xt,Fe,Z,Et,Ne,V,Tt,$e,X,Pt,Ge,ee,It,Re,W,Na=`<code class="language-javascript"><span class="token comment">// create a new sprite</span>
<span class="token keyword">const</span> sprite <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>add<span class="token punctuation">.</span><span class="token function">sprite</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token string">'mySprite'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// resize the sprite's hitbox</span>
sprite<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">setSize</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code>`,Je,u,jt,me,St,Ot,ue,Wt,zt,ye,At,Lt,ge,qt,Ct,Me,_,Dt,we,Bt,Ft,be,Nt,$t,He,j,S,ve,Gt,Ue,te,Rt,Ye,ae,Jt;return{c(){c=o("p"),g=r("I\u2019m jamming on a flappy bird type game with my son called Flappy Jacob. We\u2019ve implemented a heart point system, powerups based on a random number generator, bosses that have set patterns and attacks, and a scoring system."),w=h(),b=o("p"),f=o("strong"),y=r("Powerups -  While you\u2019re jumping through the game, different power ups appear randomly:"),O=h(),v=o("ul"),A=o("li"),oe=o("strong"),Qe=r("Shield "),Ze=r(": Player can bust through the level blocks and reflect or be immune to damage from bosses."),Ve=h(),L=o("li"),ne=o("strong"),Xe=r("Feather "),et=r(": The player\u2019s movement and jumping has less gravity applied. Boss projectiles slow down in speed."),tt=h(),q=o("li"),le=o("strong"),at=r("Weight "),it=r(": The player\u2019s movement and jumping has more gravity applied. Boss projectiles are reflected back to the boss."),_e=h(),C=o("p"),st=r("The feather and weight offer a challenging experience the way they are designed. Sometimes a weight is extremely helpful when you need to drop fast to avoid knocking into the walls. The feather can be beneficial when you need to float or glide through the walls."),ke=h(),D=o("p"),ot=r("If you get one of these powerups at the wrong time, there is a chance you\u2019ll die. It does create some momentum in the game play but many times it equals death for the player."),xe=h(),B=o("p"),nt=r("The shield is designed help the player along no matter what the situation is, allowing the player to destory walls."),Ee=h(),F=o("p"),lt=r("While these are some decent designs for the game\u2019s mechanics, these powerups still need work. Instead of these powerups appearing randomly based on set percentages, we could design the powerups to be collected and the player can use them when they want to. This design is different but allows the player to make a decision instead of accepting what happens randomly."),Te=h(),N=o("blockquote"),re=o("p"),rt=r("As game designers, we shouldn\u2019t accept any mechanic into the game unless it\u2019s been tested, iterated on, and tested again and again."),Pe=h(),$=o("p"),pt=r("Using elements randomly has the possibility of being a good design and can be another way to add additional layers to your game play loop.  On the negative end, if we have a random mechanic causes the player to die unexpectedly, too often, the design will need more iteration. Do you need to redesign the whole mechanic? Can you get by with adding another layer to the loop? Experiment with different designs and ideas. Be positive the design is in scope and can be executed."),Ie=h(),G=o("p"),ht=r("Introduce a \u201Cmiracle\u201D type situation: the player would just wiggle through enough space to pass through the walls. Magical moments can spread stories outside of the confines of your game world. Maybe that\u2019s not enough or can be exploited. Some designs may need to be more clear. The player should be able to complete the levels or areas by learning from their mistakes.  If random powerups cause deaths - no amount of learning will help."),je=h(),R=o("p"),dt=r("To solve these issues, let\u2019s look at allowing the player to choose which powerup to use at a given time.  We limit the amount of powerups that can be carried to three and allow to player to decide when to activate."),Se=h(),x=o("h2"),E=o("a"),pe=o("span"),ct=r("Balancing Act"),Oe=h(),J=o("p"),ft=r("Developing a boss encounter is incredibly enjoyable. Creating all the abilities the boss can perform and attempting to balance. Picturing a design in your head seems perfect at first, right? What could go wrong? Many times when designers are coming up with a boss fight, their mind fills in the blanks. When we see the boss in action, that\u2019s the flaws can be seen. While the boss encounter looked great in our minds and on paper, some of the gameplay wasn\u2019t thought out at all."),We=h(),M=o("p"),mt=r("For example: the bird boss that wildly kept healing over and over; when designing this fight, bird\u2019s tuning with casting its healing spell happened too often. The only strategy that works is to get a shield powerup and reflect the bird\u2019s projectiles back. As seen in the video, this gameplay creates a frustrating game play experience."),ze=h(),H=o("p"),ut=r("How do we fix this?  Let the player know the boss can heal."),Ae=h(),T=o("ul"),he=o("li"),yt=r("The first few times the bird takes damage, it heals."),gt=h(),de=o("li"),wt=r("Then when the bird is on its last life, it heals."),Le=h(),U=o("p"),bt=r("Once those conditions are met, the boss never heals again."),qe=h(),Y=o("p"),vt=r("Another example:"),Ce=h(),K=o("ul"),ce=o("li"),_t=r("The healing spell has a cast timer and additional of the powerups can be used to interupt."),De=h(),Q=o("p"),kt=r("Instead of waiting for a shield to arrive - this allows for all the powerups to contribute to the player with defeating this boss."),Be=h(),P=o("h2"),I=o("a"),fe=o("span"),xt=r("Giving the Player Leeway"),Fe=h(),Z=o("p"),Et=r("As game developers, we strive to create a fun and engaging experience for our players. One aspect of game design that requires careful consideration is the balance between player freedom and difficulty. In particular, collision detection is an area where a fine balance must be struck."),Ne=h(),V=o("p"),Tt=r("While pixel perfect collision detection can have its place in certain games, in many cases it can limit player freedom and experimentation. Tight collision detection may require the player to execute the same jump or move with the same distance every time, leaving little room for creativity or mistakes. On the other hand, perfect collision detection can allow for experimentation, but can make the game too forgiving and reduce the sense of challenge."),$e=h(),X=o("p"),Pt=r("One example of balancing player freedom and difficulty is the popular game Flappy Jacob. In this game, the player controls a character who must navigate through a series of obstacles by jumping and avoiding collision. While the game has a simple concept, it can be challenging due to the tight collision detection. If the player\u2019s hair touches the wall, the player dies."),Ge=h(),ee=o("p"),It=r("Reducing the player\u2019s hitbox slightly can provide additional freedom without significantly reducing the game\u2019s difficulty. This change allows players to make small mistakes without being penalized too harshly, while still maintaining a sense of challenge. The player can still die if they are not paying attention, being reckless, or not taking their time."),Re=h(),W=o("pre"),Je=h(),u=o("p"),jt=r("In this example, we create a new sprite at position "),me=o("code"),St=r("(100, 100)"),Ot=r(" with the key "),ue=o("code"),Wt=r("'mySprite'"),zt=r(". Then we use the "),ye=o("code"),At=r("setSize()"),Lt=r(" method to resize the sprite\u2019s hitbox to a width and height of "),ge=o("code"),qt=r("50"),Ct=r(" pixels."),Me=h(),_=o("p"),Dt=r("Note that the "),we=o("code"),Bt=r("setSize()"),Ft=r(" method sets the hitbox size in pixels, so the actual size of the hitbox will depend on the scale of the sprite and the size of the texture it is using. You can use the "),be=o("code"),Nt=r("setScale()"),$t=r(" method to adjust the scale of the sprite if needed."),He=h(),j=o("h2"),S=o("a"),ve=o("span"),Gt=r("Gameplay need time and iteration"),Ue=h(),te=o("p"),Rt=r("It is important to note that balancing player freedom and difficulty requires time and iteration. A design that appears perfect in theory may not play out well in practice. It is essential to spend time at the drawing board, consider multiple possibilities, and play with different concepts of gameplay to uncover unforeseen possibilities that players will inevitably find."),Ye=h(),ae=o("p"),Jt=r("Through this process of iteration and testing, we can create games that strike the right balance between player freedom and difficulty, providing an enjoyable and engaging experience for players."),this.h()},l(e){c=n(e,"P",{});var i=l(c);g=p(i,"I\u2019m jamming on a flappy bird type game with my son called Flappy Jacob. We\u2019ve implemented a heart point system, powerups based on a random number generator, bosses that have set patterns and attacks, and a scoring system."),i.forEach(t),w=d(e),b=n(e,"P",{});var Vt=l(b);f=n(Vt,"STRONG",{});var Xt=l(f);y=p(Xt,"Powerups -  While you\u2019re jumping through the game, different power ups appear randomly:"),Xt.forEach(t),Vt.forEach(t),O=d(e),v=n(e,"UL",{});var ie=l(v);A=n(ie,"LI",{});var Mt=l(A);oe=n(Mt,"STRONG",{});var ea=l(oe);Qe=p(ea,"Shield "),ea.forEach(t),Ze=p(Mt,": Player can bust through the level blocks and reflect or be immune to damage from bosses."),Mt.forEach(t),Ve=d(ie),L=n(ie,"LI",{});var Ht=l(L);ne=n(Ht,"STRONG",{});var ta=l(ne);Xe=p(ta,"Feather "),ta.forEach(t),et=p(Ht,": The player\u2019s movement and jumping has less gravity applied. Boss projectiles slow down in speed."),Ht.forEach(t),tt=d(ie),q=n(ie,"LI",{});var Ut=l(q);le=n(Ut,"STRONG",{});var aa=l(le);at=p(aa,"Weight "),aa.forEach(t),it=p(Ut,": The player\u2019s movement and jumping has more gravity applied. Boss projectiles are reflected back to the boss."),Ut.forEach(t),ie.forEach(t),_e=d(e),C=n(e,"P",{});var ia=l(C);st=p(ia,"The feather and weight offer a challenging experience the way they are designed. Sometimes a weight is extremely helpful when you need to drop fast to avoid knocking into the walls. The feather can be beneficial when you need to float or glide through the walls."),ia.forEach(t),ke=d(e),D=n(e,"P",{});var sa=l(D);ot=p(sa,"If you get one of these powerups at the wrong time, there is a chance you\u2019ll die. It does create some momentum in the game play but many times it equals death for the player."),sa.forEach(t),xe=d(e),B=n(e,"P",{});var oa=l(B);nt=p(oa,"The shield is designed help the player along no matter what the situation is, allowing the player to destory walls."),oa.forEach(t),Ee=d(e),F=n(e,"P",{});var na=l(F);lt=p(na,"While these are some decent designs for the game\u2019s mechanics, these powerups still need work. Instead of these powerups appearing randomly based on set percentages, we could design the powerups to be collected and the player can use them when they want to. This design is different but allows the player to make a decision instead of accepting what happens randomly."),na.forEach(t),Te=d(e),N=n(e,"BLOCKQUOTE",{});var la=l(N);re=n(la,"P",{});var ra=l(re);rt=p(ra,"As game designers, we shouldn\u2019t accept any mechanic into the game unless it\u2019s been tested, iterated on, and tested again and again."),ra.forEach(t),la.forEach(t),Pe=d(e),$=n(e,"P",{});var pa=l($);pt=p(pa,"Using elements randomly has the possibility of being a good design and can be another way to add additional layers to your game play loop.  On the negative end, if we have a random mechanic causes the player to die unexpectedly, too often, the design will need more iteration. Do you need to redesign the whole mechanic? Can you get by with adding another layer to the loop? Experiment with different designs and ideas. Be positive the design is in scope and can be executed."),pa.forEach(t),Ie=d(e),G=n(e,"P",{});var ha=l(G);ht=p(ha,"Introduce a \u201Cmiracle\u201D type situation: the player would just wiggle through enough space to pass through the walls. Magical moments can spread stories outside of the confines of your game world. Maybe that\u2019s not enough or can be exploited. Some designs may need to be more clear. The player should be able to complete the levels or areas by learning from their mistakes.  If random powerups cause deaths - no amount of learning will help."),ha.forEach(t),je=d(e),R=n(e,"P",{});var da=l(R);dt=p(da,"To solve these issues, let\u2019s look at allowing the player to choose which powerup to use at a given time.  We limit the amount of powerups that can be carried to three and allow to player to decide when to activate."),da.forEach(t),Se=d(e),x=n(e,"H2",{id:!0});var Yt=l(x);E=n(Yt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ca=l(E);pe=n(ca,"SPAN",{class:!0}),l(pe).forEach(t),ca.forEach(t),ct=p(Yt,"Balancing Act"),Yt.forEach(t),Oe=d(e),J=n(e,"P",{});var fa=l(J);ft=p(fa,"Developing a boss encounter is incredibly enjoyable. Creating all the abilities the boss can perform and attempting to balance. Picturing a design in your head seems perfect at first, right? What could go wrong? Many times when designers are coming up with a boss fight, their mind fills in the blanks. When we see the boss in action, that\u2019s the flaws can be seen. While the boss encounter looked great in our minds and on paper, some of the gameplay wasn\u2019t thought out at all."),fa.forEach(t),We=d(e),M=n(e,"P",{});var ma=l(M);mt=p(ma,"For example: the bird boss that wildly kept healing over and over; when designing this fight, bird\u2019s tuning with casting its healing spell happened too often. The only strategy that works is to get a shield powerup and reflect the bird\u2019s projectiles back. As seen in the video, this gameplay creates a frustrating game play experience."),ma.forEach(t),ze=d(e),H=n(e,"P",{});var ua=l(H);ut=p(ua,"How do we fix this?  Let the player know the boss can heal."),ua.forEach(t),Ae=d(e),T=n(e,"UL",{});var Ke=l(T);he=n(Ke,"LI",{});var ya=l(he);yt=p(ya,"The first few times the bird takes damage, it heals."),ya.forEach(t),gt=d(Ke),de=n(Ke,"LI",{});var ga=l(de);wt=p(ga,"Then when the bird is on its last life, it heals."),ga.forEach(t),Ke.forEach(t),Le=d(e),U=n(e,"P",{});var wa=l(U);bt=p(wa,"Once those conditions are met, the boss never heals again."),wa.forEach(t),qe=d(e),Y=n(e,"P",{});var ba=l(Y);vt=p(ba,"Another example:"),ba.forEach(t),Ce=d(e),K=n(e,"UL",{});var va=l(K);ce=n(va,"LI",{});var _a=l(ce);_t=p(_a,"The healing spell has a cast timer and additional of the powerups can be used to interupt."),_a.forEach(t),va.forEach(t),De=d(e),Q=n(e,"P",{});var ka=l(Q);kt=p(ka,"Instead of waiting for a shield to arrive - this allows for all the powerups to contribute to the player with defeating this boss."),ka.forEach(t),Be=d(e),P=n(e,"H2",{id:!0});var Kt=l(P);I=n(Kt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var xa=l(I);fe=n(xa,"SPAN",{class:!0}),l(fe).forEach(t),xa.forEach(t),xt=p(Kt,"Giving the Player Leeway"),Kt.forEach(t),Fe=d(e),Z=n(e,"P",{});var Ea=l(Z);Et=p(Ea,"As game developers, we strive to create a fun and engaging experience for our players. One aspect of game design that requires careful consideration is the balance between player freedom and difficulty. In particular, collision detection is an area where a fine balance must be struck."),Ea.forEach(t),Ne=d(e),V=n(e,"P",{});var Ta=l(V);Tt=p(Ta,"While pixel perfect collision detection can have its place in certain games, in many cases it can limit player freedom and experimentation. Tight collision detection may require the player to execute the same jump or move with the same distance every time, leaving little room for creativity or mistakes. On the other hand, perfect collision detection can allow for experimentation, but can make the game too forgiving and reduce the sense of challenge."),Ta.forEach(t),$e=d(e),X=n(e,"P",{});var Pa=l(X);Pt=p(Pa,"One example of balancing player freedom and difficulty is the popular game Flappy Jacob. In this game, the player controls a character who must navigate through a series of obstacles by jumping and avoiding collision. While the game has a simple concept, it can be challenging due to the tight collision detection. If the player\u2019s hair touches the wall, the player dies."),Pa.forEach(t),Ge=d(e),ee=n(e,"P",{});var Ia=l(ee);It=p(Ia,"Reducing the player\u2019s hitbox slightly can provide additional freedom without significantly reducing the game\u2019s difficulty. This change allows players to make small mistakes without being penalized too harshly, while still maintaining a sense of challenge. The player can still die if they are not paying attention, being reckless, or not taking their time."),Ia.forEach(t),Re=d(e),W=n(e,"PRE",{class:!0});var $a=l(W);$a.forEach(t),Je=d(e),u=n(e,"P",{});var k=l(u);jt=p(k,"In this example, we create a new sprite at position "),me=n(k,"CODE",{});var ja=l(me);St=p(ja,"(100, 100)"),ja.forEach(t),Ot=p(k," with the key "),ue=n(k,"CODE",{});var Sa=l(ue);Wt=p(Sa,"'mySprite'"),Sa.forEach(t),zt=p(k,". Then we use the "),ye=n(k,"CODE",{});var Oa=l(ye);At=p(Oa,"setSize()"),Oa.forEach(t),Lt=p(k," method to resize the sprite\u2019s hitbox to a width and height of "),ge=n(k,"CODE",{});var Wa=l(ge);qt=p(Wa,"50"),Wa.forEach(t),Ct=p(k," pixels."),k.forEach(t),Me=d(e),_=n(e,"P",{});var se=l(_);Dt=p(se,"Note that the "),we=n(se,"CODE",{});var za=l(we);Bt=p(za,"setSize()"),za.forEach(t),Ft=p(se," method sets the hitbox size in pixels, so the actual size of the hitbox will depend on the scale of the sprite and the size of the texture it is using. You can use the "),be=n(se,"CODE",{});var Aa=l(be);Nt=p(Aa,"setScale()"),Aa.forEach(t),$t=p(se," method to adjust the scale of the sprite if needed."),se.forEach(t),He=d(e),j=n(e,"H2",{id:!0});var Qt=l(j);S=n(Qt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var La=l(S);ve=n(La,"SPAN",{class:!0}),l(ve).forEach(t),La.forEach(t),Gt=p(Qt,"Gameplay need time and iteration"),Qt.forEach(t),Ue=d(e),te=n(e,"P",{});var qa=l(te);Rt=p(qa,"It is important to note that balancing player freedom and difficulty requires time and iteration. A design that appears perfect in theory may not play out well in practice. It is essential to spend time at the drawing board, consider multiple possibilities, and play with different concepts of gameplay to uncover unforeseen possibilities that players will inevitably find."),qa.forEach(t),Ye=d(e),ae=n(e,"P",{});var Ca=l(ae);Jt=p(Ca,"Through this process of iteration and testing, we can create games that strike the right balance between player freedom and difficulty, providing an enjoyable and engaging experience for players."),Ca.forEach(t),this.h()},h(){m(pe,"class","icon icon-link"),m(E,"aria-hidden","true"),m(E,"tabindex","-1"),m(E,"href","#balancing-act"),m(x,"id","balancing-act"),m(fe,"class","icon icon-link"),m(I,"aria-hidden","true"),m(I,"tabindex","-1"),m(I,"href","#giving-the-player-leeway"),m(P,"id","giving-the-player-leeway"),m(W,"class","language-javascript"),m(ve,"class","icon icon-link"),m(S,"aria-hidden","true"),m(S,"tabindex","-1"),m(S,"href","#gameplay-need-time-and-iteration"),m(j,"id","gameplay-need-time-and-iteration")},m(e,i){s(e,c,i),a(c,g),s(e,w,i),s(e,b,i),a(b,f),a(f,y),s(e,O,i),s(e,v,i),a(v,A),a(A,oe),a(oe,Qe),a(A,Ze),a(v,Ve),a(v,L),a(L,ne),a(ne,Xe),a(L,et),a(v,tt),a(v,q),a(q,le),a(le,at),a(q,it),s(e,_e,i),s(e,C,i),a(C,st),s(e,ke,i),s(e,D,i),a(D,ot),s(e,xe,i),s(e,B,i),a(B,nt),s(e,Ee,i),s(e,F,i),a(F,lt),s(e,Te,i),s(e,N,i),a(N,re),a(re,rt),s(e,Pe,i),s(e,$,i),a($,pt),s(e,Ie,i),s(e,G,i),a(G,ht),s(e,je,i),s(e,R,i),a(R,dt),s(e,Se,i),s(e,x,i),a(x,E),a(E,pe),a(x,ct),s(e,Oe,i),s(e,J,i),a(J,ft),s(e,We,i),s(e,M,i),a(M,mt),s(e,ze,i),s(e,H,i),a(H,ut),s(e,Ae,i),s(e,T,i),a(T,he),a(he,yt),a(T,gt),a(T,de),a(de,wt),s(e,Le,i),s(e,U,i),a(U,bt),s(e,qe,i),s(e,Y,i),a(Y,vt),s(e,Ce,i),s(e,K,i),a(K,ce),a(ce,_t),s(e,De,i),s(e,Q,i),a(Q,kt),s(e,Be,i),s(e,P,i),a(P,I),a(I,fe),a(P,xt),s(e,Fe,i),s(e,Z,i),a(Z,Et),s(e,Ne,i),s(e,V,i),a(V,Tt),s(e,$e,i),s(e,X,i),a(X,Pt),s(e,Ge,i),s(e,ee,i),a(ee,It),s(e,Re,i),s(e,W,i),W.innerHTML=Na,s(e,Je,i),s(e,u,i),a(u,jt),a(u,me),a(me,St),a(u,Ot),a(u,ue),a(ue,Wt),a(u,zt),a(u,ye),a(ye,At),a(u,Lt),a(u,ge),a(ge,qt),a(u,Ct),s(e,Me,i),s(e,_,i),a(_,Dt),a(_,we),a(we,Bt),a(_,Ft),a(_,be),a(be,Nt),a(_,$t),s(e,He,i),s(e,j,i),a(j,S),a(S,ve),a(j,Gt),s(e,Ue,i),s(e,te,i),a(te,Rt),s(e,Ye,i),s(e,ae,i),a(ae,Jt)},p:Va,d(e){e&&t(c),e&&t(w),e&&t(b),e&&t(O),e&&t(v),e&&t(_e),e&&t(C),e&&t(ke),e&&t(D),e&&t(xe),e&&t(B),e&&t(Ee),e&&t(F),e&&t(Te),e&&t(N),e&&t(Pe),e&&t($),e&&t(Ie),e&&t(G),e&&t(je),e&&t(R),e&&t(Se),e&&t(x),e&&t(Oe),e&&t(J),e&&t(We),e&&t(M),e&&t(ze),e&&t(H),e&&t(Ae),e&&t(T),e&&t(Le),e&&t(U),e&&t(qe),e&&t(Y),e&&t(Ce),e&&t(K),e&&t(De),e&&t(Q),e&&t(Be),e&&t(P),e&&t(Fe),e&&t(Z),e&&t(Ne),e&&t(V),e&&t($e),e&&t(X),e&&t(Ge),e&&t(ee),e&&t(Re),e&&t(W),e&&t(Je),e&&t(u),e&&t(Me),e&&t(_),e&&t(He),e&&t(j),e&&t(Ue),e&&t(te),e&&t(Ye),e&&t(ae)}}}function ti(z){let c,g;const w=[z[0],Fa];let b={$$slots:{default:[ei]},$$scope:{ctx:z}};for(let f=0;f<w.length;f+=1)b=Zt(b,w[f]);return c=new Xa({props:b}),{c(){Ma(c.$$.fragment)},l(f){Ha(c.$$.fragment,f)},m(f,y){Ua(c,f,y),g=!0},p(f,[y]){const O=y&1?Ya(w,[y&1&&Da(f[0]),y&0&&Da(Fa)]):{};y&2&&(O.$$scope={dirty:y,ctx:f}),c.$set(O)},i(f){g||(Ka(c.$$.fragment,f),g=!0)},o(f){Qa(c.$$.fragment,f),g=!1},d(f){Za(c,f)}}}const Fa={title:"Flappy Jacob Prototype",date:"2020-08-18",modifiedDate:"2023-03-30",categories:["game development","phaser"],svg:"Balance",seoImage:"https://boatr.s3.amazonaws.com/static/media/uploads/blog/blog_jac.jpg",shortDescription:"Jamming on a flappy bird type game with my son called Flappy Jacob. We've implemented a heart point system, powerups based on a random number generator, bosses that have set patterns and attacks, and a scoring system.",author:"Ryan Sadwick",videos:[{width:"100%",height:600,controls:!0,poster:"https://3ee.s3.amazonaws.com/video/flappy_prototype.webp",srcs:[{src:"https://3ee.s3.amazonaws.com/video/flappy_prototype.mp4",type:"video/mp4"}]}]};function ai(z,c,g){return z.$$set=w=>{g(0,c=Zt(Zt({},c),Ba(w)))},c=Ba(c),[c]}class ri extends Ga{constructor(c){super(),Ra(this,c,ai,ti,Ja,{})}}export{ri as default,Fa as metadata};
